function Ifusion_Control_Points(axes_left, axes_right)
%
% Ifusion_Control_Points(axes_left, axes_right)
%
% SYNOPSIS: This function, starting from the path generated by the function
%           'catetherPathFast.m', generates appropriate control points.
%           This function is called only once, just after the path
%           generation.
%
% INPUT:    axes_left:      the handles of the left axes in the
%                           interface_2.m
%           axes_right:     the handles of the right axes in the
%                           interface_2.m
%
% OUTPUT:   None. It modifies global variables that describes the 2D and 3D
%           models.
%
% REF:
%
% COMMENTS:
%

%
% Access to global variables
%
Ifusion_Global
%
% Check whether the current case has been uploaded or not.
% If the case was uploaded (old_case == 1), we just place the control
% points on the position they were saved for both curves.
% 
if old_case == 1
    %
    % We load the control points for both curves and set the number of 
    % control points
    %
    load(Patient_case,'ctrl_pts1','ctrl_pts2');
    N_ctrl_pts=size(ctrl_pts1,1);
    for id=1:N_ctrl_pts
        %
        % Generate a new control point into the left axis (using the MATLAB
        % command 'impoint' and assign its handles to the control point in the
        % structure Curves.
        %
        Curves{1}.control_pts{id} = impoint(axes_left, ctrl_pts1(id,1), ctrl_pts1(id,2));
        %
        % Generate the api for the handle just assigned.
        %
        Curves{1}.api{id} = iptgetapi(Curves{1}.control_pts{id});
        %
        % Add a constraint to the api not to let the point get out of the axes.
        %
        fcn = makeConstrainToRectFcn('impoint',get(axes_left,'XLim'),get(axes_left,'YLim'));
        Curves{1}.api{id}.setPositionConstraintFcn(fcn);
        
        %
        % Here, we do the same procces above for the right curve 
        %
        Curves{2}.control_pts{id} = impoint(axes_right, ctrl_pts2(id,1), ctrl_pts2(id,2));
        Curves{2}.api{id} = iptgetapi(Curves{2}.control_pts{id});
        fcn = makeConstrainToRectFcn('impoint',get(axes_right,'XLim'),get(axes_right,'YLim'));
        Curves{2}.api{id}.setPositionConstraintFcn(fcn);
    end
else 
    %
    %% CUT THE 'LEFT'PATH IN EQUALLY SPACED SEGMENTS and 
    %  Assign a control point to every segment boundary

    
    %
    % Take the 'left' path, and cut it in 4 parts equally spaced. Add a control
    % point at each side of the parts, for a total of N_ctrl_pts control points.
    %
    
    %
    % Initialize 'id' as the index of the control points.
    %
    id = 1;
    
    %
    % For all points at index 'i', equally spaced depending on the size of the
    % input path. As an example, i can be equal to [1 28  55  82  109].
    %
    for i = round(linspace(1,size(Curves{1}.coor,1),N_ctrl_pts));
        %
        % Generate a new control point into the left axis (using the MATLAB
        % command 'impoint' and assign its handles to the control point in the
        % structure Curves.
        %
        Curves{1}.control_pts{id} = impoint(axes_left, Curves{1}.coor(i,2), Curves{1}.coor(i,1));
        %
        % Generate the api for the handle just assigned.
        %
        Curves{1}.api{id} = iptgetapi(Curves{1}.control_pts{id});
        %
        % Add a constraint to the api not to let the point get out of the axes.
        %
        fcn = makeConstrainToRectFcn('impoint',get(axes_left,'XLim'),get(axes_left,'YLim'));
        Curves{1}.api{id}.setPositionConstraintFcn(fcn);
        
        %
        % Increase id to go to next control point.
        %
        id = id + 1;
    end
    
    %
    %%  ASSIGN A CONTROL POINT TO START AND END OF THE 'RIGHT' PATH
    %
    
    %
    % To set the control points of the 'right' curve, it is necessary to cut
    % the curve using non-equal spacing. This is because actually the two 2D
    % curves represent the same 3D curve but under different projection.
    % Obviously, a projection can modify the lenght of different parts of the
    % curve depending on their orientation with respect of the direction of
    % projection.
    %
    % To assign meaningful control points, we have to employ a more complex
    % method.
    %
    
    %
    % We first fix first and last control points respectively to the beginning
    % and end of the curve. This points are important to delimitate the curve size.
    %
    
    %
    % Generate the spatial constraint function.
    %
    fcn = makeConstrainToRectFcn('impoint',get(axes_right,'XLim'),get(axes_right,'YLim'));
    
    %
    % Set the first control point to the beginning of the 'right' path.
    %
    Curves{2}.control_pts{1} = impoint(axes_right,Curves{2}.coor(1,2),Curves{2}.coor(1,1));
    Curves{2}.api{1}         = iptgetapi(Curves{2}.control_pts{1});
    %
    % Add a constraint to the api not to let the point get out of the axes.
    %
    Curves{2}.api{1}.setPositionConstraintFcn(fcn);
    
    %
    % Set the last control point to the end of the 'right' path.
    %
    Curves{2}.control_pts{N_ctrl_pts} = impoint(axes_right,Curves{2}.coor(end,2),Curves{2}.coor(end,1));
    Curves{2}.api{N_ctrl_pts}         = iptgetapi(Curves{2}.control_pts{N_ctrl_pts});
    %
    % Add a constraint to the api not to let the point get out of the axes.
    %
    Curves{2}.api{N_ctrl_pts}.setPositionConstraintFcn(fcn);
    
    %
    %% For each inner control point, compute the intersection of its
    %  Epipolar with the ‘right’ curve and Assign a control point 
    %  to each intersection in the ‘right’ path.
    %
    
    %
    % For the inner control points of the 'right' curve, we set the control
    % point at the intersection of the path and the epipolar generated by the
    % corresponding control point in the 'left' curve.
    %
    for id=2:N_ctrl_pts-1
        %
        % Compute the epipolar generated by the corresponding control point on
        % the 'left' curve.
        %
        epi = Epipolar(Curves{1}.control_pts{id}.getPosition()-round(im_size/2), F(2), F(1), ...
            C(2), C(1), l(1,:), c(1,:), k(1,:), l(2,:), c(2,:), k(2,:));
        %
        % Adapt the epipolar line to the image domain of the 'right' curve
        %
        epi = StretchLine(epi + round(im_size/2), [ 1 1 [im_size im_size]]);
        
        %
        % Store the beginning and end of the epipolar line in variable pa, pb
        %
        pa = epi(1,:);
        pb = epi(2,:);
        
        %
        % Computes the norm of the segment from pa to pb
        %
        dab = norm(pa-pb);
        
        %
        % For all the points of the 'right' path
        %
        for i = 1:size(Curves{2}.coor,1)
            %
            % Store the point coordinates to pc
            %
            pc = [Curves{2}.coor(i,1) Curves{2}.coor(i,2)];
            
            %
            % The intersection point is the one that minimizes the difference
            % between the sum of the length of segments (pa to pc), (pb to pc)
            % the length of the segment (pa to pb). We compute this difference
            % for all the points of the path.
            %
            
            %
            % Store the difference in the vector err_pc
            %
            err_pc(i) = norm(pa-pc) + norm(pb-pc) - dab;
        end
        
        %
        % Find the index 'index' that minimize err_pc
        %
        index = find(err_pc == min(err_pc));
        
        %
        % In the case, there is more than one minimum, select the first one.
        %
        index = index(1);
        
        %
        % Set the control points parameters and position
        %
        Curves{2}.control_pts{id} = impoint(axes_right,Curves{2}.coor(index,2),Curves{2}.coor(index,1));
        Curves{2}.api{id}         = iptgetapi(Curves{2}.control_pts{id});
        Curves{2}.api{id}.setPositionConstraintFcn(fcn);
    end
    %
    %% For each pair of control points (Left and Right) estimate the 3D point in global reference system
    %
    
    %
    % Backprojection of 2D points from both 'left' and 'right' curves to form
    % the 3D curve.
    %
    
    %
    % Initialize an empty vector for the 3D points
    %
    pts3D=[];
    
    %
    % For all the control points, taken as pairs of 'left' and corresponding
    % 'right'
    %
    for i=1:N_ctrl_pts
        %
        % Store the coordinates of pairs of control points, converting from
        % image plane (in pixel) to real mm.
        %
        v1(i,:) = (Curves{1}.control_pts{i}.getPosition() - round(im_size/2)) * sc_fact;
        v2(i,:) = (Curves{2}.control_pts{i}.getPosition() - round(im_size/2)) * sc_fact;
    end
    
    %
    % Compute the 3D points as the intersection of pairs of antiprojected
    % control points. See the details in function 'Intersection_line_line.m'
    %
    for i=1:N_ctrl_pts
        pts3D(i,:) = Intersection_line_line(-k(1,:)*(v1(i,1))+l(1,:)*(v1(i,2))+C(1)*c(1,:), ...
            -c(1,:)*F(1), ...
            -k(2,:)*(v2(i,1))+l(2,:)*(v2(i,2))+C(2)*c(2,:), ...
            -c(2,:)*F(2) );
    end
   
    %
    %% For each 3D point, apply 3D to 2D projection on both images
    %  and Set the control points positions as the 2D projections of just
    %  computed 3D points
    %
    
    %
    % Project 3D points back to both 'left' and 'right' projection. This
    % assures that 2D curves are consistent each other, and with the 3D model.
    %
    for id=1:N_ctrl_pts
        %
        % This command finds the 3D intersection point between
        % the Left plane and the line containing the 3D control point and
        % the focus of the plane.
        %
        temp = Intersection_plane_line(pts3D(id,:), -F(1)*c(1,:), C(1)*c(1,:), c(1,:));
        
        %
        % Project to image plane in pixels
        %
        temp = ([l(1,:); -k(1,:)]'\ (temp-(C(1)*c(1,:)))')' / sc_fact;
        
        %
        % Convert to local reference system in pixels
        %
        temp = temp + round(im_size/2);
        
        %
        % Update the position of the control point.
        %
        Curves{1}.control_pts{id}.setPosition( temp(2),temp(1) );
        
        %
        % This command finds the 3D intersection point between
        % the Right plane and the line containing the 3D control point and
        % the focus of the plane.
        %
        temp = Intersection_plane_line(pts3D(id,:), -F(2)*c(2,:), C(2)*c(2,:), c(2,:));
        
        %
        % Project to image plane in pixels
        %
        temp = ([l(2,:); -k(2,:)]'\ (temp-(C(2)*c(2,:)))')' / sc_fact;
        
        %
        % Convert to local reference system in pixels
        %
        temp = temp + round(im_size/2);
        
        %
        % Update the position of the control point.
        %
        Curves{2}.control_pts{id}.setPosition( temp(2),temp(1) );
    end
    
    
end
%
% For each control points link the 'UserinteractionCurve.m' function to the
% callback related to the change of position.
%
% For the 'left' curve
for id=1:N_ctrl_pts
    Curves{1}.id_fun{id}      = Curves{1}.api{id}.addNewPositionCallback(@(p)UserinteractionCurve(axes_left, axes_right,axes_left,1,Curves{1}.api));
    Curves{1}.old_curve(id,:) = [Curves{1}.control_pts{id}.getPosition()];
end

% For the 'right' curve
for id=1:N_ctrl_pts
    Curves{2}.id_fun{id}      = Curves{2}.api{id}.addNewPositionCallback(@(p)UserinteractionCurve(axes_left, axes_right,axes_right,2,Curves{2}.api));
    Curves{2}.old_curve(id,:) = [Curves{2}.control_pts{id}.getPosition()];
end

%
% Once the control points have been placed, to convert the path to a
% interpolated curve we apply a small movement to implicitly call the
% function 'UserinteractionCurve.m'. That function does all the necessary
% steps. Then we place the point back to the 'original' position.
%
% This is a 'trick' to visualize the interpolated curve as soon as the path
% is generated.
%
fake = Curves{1}.control_pts{1}.getPosition();
Curves{1}.control_pts{1}.setPosition( fake + 0.01 );
Curves{1}.control_pts{1}.setPosition( fake );


